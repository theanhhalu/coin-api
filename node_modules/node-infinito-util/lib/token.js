const ShaJs = require('sha.js');
const Util = require('util');
const Messages = require('./messages');
const Http = require('./http');
const Logger = require('./logger');
const AppError = require('./app_error');
const AsyncLock = require('./asynclock');

/** 
 * Token provider 
 * 
 * @class TokenProvider 
 */
class TokenProvider {

  /** 
   * Creates an instance of TokenProvider. 
   * @param {Object} options 
   * @param {String} options.apiKey              (required) API Key 
   * @param {String} options.secret              (required) Secret Key 
   * @param {String} options.url                 (required) Base url of api 
   * @memberof TokenProvider 
   */
  constructor(options) {
    this._enforce(options, ['apiKey', 'secret', 'url']);

    this.apiKey = options.apiKey;
    this.secret = options.secret;
    this.url = options.url;
    this.lock = new AsyncLock();

    this.latestToken = null;
  }

  /** 
   * Set latest token 
   * 
   * @param {*} newToken 
   * @memberof TokenProvider 
   */
  setToken(newToken) {
    this.latestToken = newToken;
  }

  /** 
   * Clear token 
   * 
   * @memberof TokenProvider 
   */
  clearToken() {
    this.setToken(null);
  }

  /** 
   * Get latest token. Get new token if it is not exists. 
   * 
   * @returns 
   * @memberof TokenProvider 
   */
  async getLatestToken() {
    if (this.latestToken) {
      return this.latestToken;
    }

    let token = this.getNewTokenOnce();
    this.setToken(token);
    return token;
  }

  /** 
   * Refresh latest token 
   * 
   * @returns 
   * @memberof TokenProvider 
   */
  async getNewTokenOnce() {
    let result = await this.lock.acquire();
    if (result === true) {
      let token = this.getNewToken();
      this.lock.release(token);
      return token;
    }

    return result;
  }

  /** 
   * Get new token 
   * 
   * @returns 
   * @memberof TokenProvider 
   */
  async getNewToken() {
    let hashParam = this._getHash(this.apiKey, this.secret);
    try {
      let result = await Http.send(
        this.url,
        'POST',
        {
          'Content-Type': 'application/json',
          api_sign: hashParam.hashKey
        },
        {
          api_key: this.apiKey,
          nonce: hashParam.nonce
        });

      return result.data.data.token;
    } catch (err) {
      Logger.error('getNewToken: ', err);
      if (err.response.status === 401)
        throw new AppError(Messages.invalid_api_key.message, Messages.invalid_api_key.code, err.response.status);
      throw new AppError(Messages.internal_error.message, Messages.internal_error.code, err.response.status);
    }
  }

  /** 
   * Enforce require key in object 
   * 
   * @param {Object} options 
   * @param {Array[String]} requiredKeys 
   * @memberof Api 
   */
  _enforce(options, requiredKeys) {
    if (!options || typeof options !== 'object') {
      throw new AppError(Util.format(Messages.missing_parameter.message, 'options'), Messages.missing_parameter.code);
    }

    requiredKeys.forEach(function (requiredKey) {
      if (!options[requiredKey])
        throw new AppError(Util.format(Messages.missing_parameter.message, `options.${requiredKey}`), Messages.missing_parameter.code);
    });
  }

  /** 
   * Generate hash 
   * 
   * @returns 
   * @memberof TokenProvider 
   */
  _getHash() {
    let nonce = Math.round(new Date().getTime() / 1000);
    let compositedKey = `/auth/token?api_key=${this.apiKey}&nonce=${nonce}&secret=${this.secret}`;
    let hashKey = new ShaJs.sha256().update(compositedKey).digest('hex');
    return { hashKey, nonce };
  }

}

module.exports = TokenProvider; 